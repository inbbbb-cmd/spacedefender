<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>üöÄ Space Defender v4.0</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            color-scheme: dark;
            --bg-top: #050510;
            --bg-bottom: #161633;
            --accent: #00f5ff;
            --accent-2: #ff00ff;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(to bottom, var(--bg-top), var(--bg-bottom));
        }
        canvas { display: block; width: 100%; height: 100%; }
        button { font-family: inherit; }
        #startScreen, #gameOverScreen, #eventBanner {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            background: rgba(3, 3, 15, 0.92);
            z-index: 20;
            gap: 14px;
            padding: clamp(20px, 5vw, 60px);
        }
        #eventBanner {
            background: transparent;
            pointer-events: none;
            animation: fadeIn 0.3s ease;
        }
        #eventBanner span {
            background: rgba(5, 5, 25, 0.85);
            padding: 14px 26px;
            border-radius: 50px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--accent);
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.6);
        }
        .title {
            font-size: clamp(36px, 8vw, 72px);
            font-weight: 900;
            background: linear-gradient(120deg, #00f5ff, #a855f7, #facc15);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle { color: #9ca3af; font-size: clamp(13px, 3vw, 20px); }
        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 999px;
            padding: 14px 46px;
            color: #fff;
            font-size: clamp(16px, 3.5vw, 22px);
            font-weight: 700;
            cursor: pointer;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .btn:hover, .btn:active { transform: scale(1.05); box-shadow: 0 10px 40px rgba(118, 75, 162, 0.6); }
        #versionBadge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.55);
            border: 1px solid rgba(0, 245, 255, 0.4);
            border-radius: 999px;
            color: var(--accent);
            padding: 4px 14px;
            font-size: 12px;
            font-weight: 700;
            z-index: 30;
        }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            z-index: 15;
            pointer-events: none;
        }
        .hud-item {
            background: rgba(0, 0, 0, 0.65);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 999px;
            padding: 6px 12px;
            font-size: clamp(10px, 2.5vw, 14px);
            display: flex;
            align-items: center;
            gap: 6px;
            backdrop-filter: blur(6px);
            color: #fff;
        }
        .health-bar {
            width: clamp(80px, 20vw, 150px);
            height: 10px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #22c55e);
            transition: width 0.2s;
        }
        #overdriveBar {
            width: clamp(80px, 20vw, 160px);
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 999px;
            overflow: hidden;
        }
        #overdriveFill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #f59e0b, #facc15);
            transition: width 0.2s;
        }
        #comboPopup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(30px, 9vw, 80px);
            font-weight: 800;
            color: var(--accent-2);
            text-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
            opacity: 0;
            pointer-events: none;
            z-index: 18;
        }
        #comboPopup.show {
            animation: combo 0.6s ease;
        }
        @keyframes combo {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.4); }
            30% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
        #mobileControls {
            position: absolute;
            inset: auto 0 10px 0;
            height: 200px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            padding: 0 16px;
            z-index: 25;
        }
        #joystickArea {
            position: relative;
            width: 150px;
            height: 150px;
            pointer-events: auto;
        }
        #joystickBase, #joystickThumb {
            position: absolute;
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        #joystickBase {
            width: 130px;
            height: 130px;
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(0, 245, 255, 0.4);
        }
        #joystickThumb {
            width: 55px;
            height: 55px;
            background: radial-gradient(circle, #00f5ff, #0077ff);
            box-shadow: 0 0 25px rgba(0, 245, 255, 0.6);
        }
        #fireButton, #overdriveButton {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 34px;
            font-weight: 700;
            color: #fff;
            border: 3px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.4);
        }
        #fireButton {
            background: radial-gradient(circle, #ff5a5a, #b91c1c);
        }
        #overdriveButton {
            background: radial-gradient(circle, #facc15, #c2410c);
            margin-left: 12px;
        }
        #pauseButton {
            position: absolute;
            top: 70px;
            right: 10px;
            width: 48px;
            height: 48px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 25;
            cursor: pointer;
            backdrop-filter: blur(4px);
        }
        .hidden { display: none !important; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in { animation: fadeIn 0.4s ease; }
        @media (pointer: fine) and (min-width: 1024px) {
            #mobileControls, #pauseButton { display: none; }
        }
    </style>
</head>
<body>
    <div id="versionBadge">v4.0 Quantum Burst</div>
    <div id="comboPopup"></div>
    <div id="eventBanner" class="hidden"><span id="eventText"></span></div>

    <div id="hud" class="hidden">
        <div class="hud-item">
            ‚ù§Ô∏è
            <div class="health-bar"><div class="health-fill" id="healthFill"></div></div>
        </div>
        <div class="hud-item">üéØ –û—á–∫–∏: <strong id="scoreDisplay">0</strong></div>
        <div class="hud-item">üåä –í–æ–ª–Ω–∞: <strong id="waveDisplay">1</strong></div>
        <div class="hud-item">üî• –ö–æ–º–±–æ: <strong id="comboDisplay">x1</strong></div>
        <div class="hud-item">‚ö° –ë–æ–Ω—É—Å: <strong id="powerDisplay">-</strong></div>
        <div class="hud-item">
            üöÄ Overdrive
            <div id="overdriveBar"><div id="overdriveFill"></div></div>
        </div>
    </div>

    <div id="pauseButton" class="hidden" onclick="togglePause()">‚è∏Ô∏è</div>

    <div id="startScreen" class="fade-in">
        <div class="title">SPACE DEFENDER</div>
        <p class="subtitle">–í–µ—Ä—Å–∏—è 4.0 –ø—Ä–∏–Ω–æ—Å–∏—Ç Overdrive, –º–µ—Ç–µ–æ—Ä–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è –∏ —É–º–Ω—ã—Ö –≤—Ä–∞–≥–æ–≤. –ó–∞—â–∏—Ç–∏ —Å–µ–∫—Ç–æ—Ä Zeta!</p>
        <div class="subtitle">
            <strong>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:</strong><br>
            ‚Üê ‚Üí ‚Üë ‚Üì –∏–ª–∏ WASD ‚Äî –¥–≤–∏–∂–µ–Ω–∏–µ ¬∑ –ü—Ä–æ–±–µ–ª ‚Äî —Å—Ç—Ä–µ–ª—å–±–∞ ¬∑ Shift ‚Äî Overdrive ¬∑ P/ESC ‚Äî –ø–∞—É–∑–∞
        </div>
        <div class="subtitle">–ù–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö: –¥–∂–æ–π—Å—Ç–∏–∫ + –∫–Ω–æ–ø–∫–∏ üî• –∏ ‚ö°</div>
        <button class="btn" onclick="startGame()">–°—Ç–∞—Ä—Ç</button>
    </div>

    <div id="gameOverScreen" class="hidden">
        <div class="title" style="font-size: clamp(30px, 7vw, 52px);">GAME OVER</div>
        <p class="subtitle">–ì–∞–ª–∞–∫—Ç–∏–∫–∞ –∂–¥—ë—Ç —Ç–≤–æ–µ–≥–æ –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏—è.</p>
        <p class="subtitle">–û—á–∫–∏: <strong id="finalScore">0</strong></p>
        <p class="subtitle">–í–æ–ª–Ω–∞: <strong id="finalWave">1</strong></p>
        <p class="subtitle">–ú–∞–∫—Å. –∫–æ–º–±–æ: <strong id="finalCombo">x1</strong></p>
        <p class="subtitle">–†–µ–∫–æ—Ä–¥: <strong id="highScore">0</strong></p>
        <button class="btn" onclick="startGame()">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
    </div>

    <div id="mobileControls" class="hidden">
        <div id="joystickArea">
            <div id="joystickBase"></div>
            <div id="joystickThumb"></div>
        </div>
        <div style="display: flex; align-items: flex-end; gap: 12px;">
            <div id="overdriveButton">‚ö°</div>
            <div id="fireButton">üî•</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const hud = document.getElementById('hud');
        const healthFill = document.getElementById('healthFill');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const waveDisplay = document.getElementById('waveDisplay');
        const comboDisplay = document.getElementById('comboDisplay');
        const powerDisplay = document.getElementById('powerDisplay');
        const overdriveFill = document.getElementById('overdriveFill');
        const comboPopup = document.getElementById('comboPopup');
        const eventBanner = document.getElementById('eventBanner');
        const eventText = document.getElementById('eventText');
        const pauseButton = document.getElementById('pauseButton');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScore = document.getElementById('finalScore');
        const finalWave = document.getElementById('finalWave');
        const finalCombo = document.getElementById('finalCombo');
        const highScoreEl = document.getElementById('highScore');

        const isMobile = /Android|iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || ('ontouchstart' in window && window.innerWidth < 1100);

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 100));

        // Game state
        let player, bullets, enemies, particles, powerups, meteors, stars;
        let score = 0;
        let wave = 1;
        let highScore = Number(localStorage.getItem('sd40-highscore') || 0);
        let keys = {};
        let lastFire = 0;
        let gameRunning = false;
        let paused = false;
        let spawnTimer = 0;
        let enemyGoal = 0;
        let killsThisWave = 0;
        let combo = 1;
        let maxCombo = 1;
        let comboTimer = 0;
        let currentPower = null;
        let powerTimer = 0;
        let overdrive = 0;
        let overdriveActive = false;
        let overdriveTimer = 0;
        let meteorEventTimer = 0;
        let meteorActive = false;
        let lastTime = 0;
        let accumulator = 0;
        const FIXED_DT = 1000 / 60;

        // Mobile controls
        let joystickActive = false;
        let joystickVector = { x: 0, y: 0 };
        let fireHeld = false;

        class Player {
            constructor() {
                this.width = 50;
                this.height = 60;
                this.x = canvas.width / 2 - this.width / 2;
                this.y = canvas.height - (isMobile ? 240 : 140);
                this.speed = 6;
                this.health = 100;
                this.maxHealth = 100;
                this.fireRate = 130;
                this.baseFireRate = 130;
                this.bulletDamage = 25;
                this.bulletSpeed = 11;
                this.tripleShot = false;
                this.invulnerable = false;
                this.invulnerableTimer = 0;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);

                if (this.invulnerable) {
                    ctx.globalAlpha = 0.6 + 0.4 * Math.sin(Date.now() / 80);
                }

                const g = ctx.createLinearGradient(0, -30, 0, 30);
                g.addColorStop(0, '#e0e7ff');
                g.addColorStop(1, '#1d4ed8');
                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.moveTo(0, -30);
                ctx.lineTo(20, 28);
                ctx.lineTo(-20, 28);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = '#0ea5e9';
                ctx.beginPath();
                ctx.arc(0, -5, 10, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();

                if (currentPower === 'shield') {
                    ctx.strokeStyle = `rgba(0, 245, 255, ${0.5 + 0.4 * Math.sin(Date.now() / 150)})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x + this.width / 2, this.y + this.height / 2, 45, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            update(dt) {
                let vx = 0, vy = 0;
                if (keys['ArrowLeft'] || keys['KeyA']) vx -= 1;
                if (keys['ArrowRight'] || keys['KeyD']) vx += 1;
                if (keys['ArrowUp'] || keys['KeyW']) vy -= 1;
                if (keys['ArrowDown'] || keys['KeyS']) vy += 1;
                if (joystickActive) {
                    vx += joystickVector.x;
                    vy += joystickVector.y;
                }
                const len = Math.hypot(vx, vy) || 1;
                this.x += (vx / len) * this.speed * dt;
                this.y += (vy / len) * this.speed * dt;
                const bottom = canvas.height - (isMobile ? 220 : 20) - this.height;
                this.x = Math.max(10, Math.min(canvas.width - this.width - 10, this.x));
                this.y = Math.max(50, Math.min(bottom, this.y));
                if (this.invulnerable) {
                    this.invulnerableTimer -= dt * 16.6;
                    if (this.invulnerableTimer <= 0) this.invulnerable = false;
                }
            }
            shoot() {
                const now = performance.now();
                const rate = overdriveActive ? this.fireRate / 2 : this.fireRate;
                if (now - lastFire < rate) return;
                lastFire = now;
                const base = { x: this.x + this.width / 2, y: this.y };
                const bulletSpeed = overdriveActive ? 15 : this.bulletSpeed;
                const damage = overdriveActive ? this.bulletDamage + 15 : this.bulletDamage;
                const spawnBullet = angle => bullets.push(new Bullet(base.x, base.y, angle, bulletSpeed, damage, false));
                if (this.tripleShot || overdriveActive) {
                    [-0.14, 0, 0.14].forEach(spawnBullet);
                } else {
                    spawnBullet(0);
                }
                if (bullets.length > 400) bullets.splice(0, bullets.length - 400);
            }
            damage(amount) {
                if (this.invulnerable || currentPower === 'shield') return;
                this.health -= amount;
                this.invulnerable = true;
                this.invulnerableTimer = 1000;
                updateHealth();
                resetCombo();
                if (this.health <= 0) gameOver();
            }
        }

        class Bullet {
            constructor(x, y, spread, speed, damage, enemy) {
                this.x = x;
                this.y = y;
                this.spread = spread;
                this.speed = speed;
                this.damage = damage;
                this.enemy = enemy;
                this.radius = enemy ? 5 : 4;
            }
            draw() {
                ctx.beginPath();
                ctx.fillStyle = this.enemy ? '#f87171' : '#34d399';
                ctx.shadowColor = this.enemy ? '#f87171' : '#34d399';
                ctx.shadowBlur = 8;
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            update(dt) {
                this.x += Math.sin(this.spread) * 6 * dt;
                this.y += (this.enemy ? 1 : -1) * this.speed * dt;
            }
        }

        class Enemy {
            constructor(type = 'basic') {
                this.type = type;
                this.width = 34;
                this.height = 34;
                this.health = 45;
                this.speed = 2 + wave * 0.12;
                this.score = 120;
                this.color = '#fb7185';
                this.pattern = Math.random() * Math.PI * 2;
                if (type === 'fast') {
                    this.width = 26;
                    this.height = 26;
                    this.speed = 3.6 + wave * 0.16;
                    this.health = 25;
                    this.score = 160;
                    this.color = '#facc15';
                }
                if (type === 'tank') {
                    this.width = 56;
                    this.height = 56;
                    this.speed = 1.3 + wave * 0.08;
                    this.health = 160;
                    this.score = 320;
                    this.color = '#38bdf8';
                    this.cooldown = 0;
                }
                if (type === 'zigzag') {
                    this.width = 36;
                    this.height = 36;
                    this.speed = 2.4;
                    this.health = 70;
                    this.score = 250;
                    this.color = '#a855f7';
                }
                if (type === 'boss') {
                    this.width = 100;
                    this.height = 70;
                    this.speed = 1.2;
                    this.health = 380 + wave * 90;
                    this.score = 1200;
                    this.color = '#fb7185';
                    this.cooldown = 0;
                }
                this.maxHealth = this.health;
                this.x = Math.random() * (canvas.width - this.width);
                this.y = -this.height - 20;
                if (type === 'boss') this.x = canvas.width / 2 - this.width / 2;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                const grd = ctx.createRadialGradient(0, 0, 6, 0, 0, this.width);
                grd.addColorStop(0, '#fff');
                grd.addColorStop(1, this.color);
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.width / 2, this.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                if ((this.type === 'tank' || this.type === 'boss') && this.health < this.maxHealth) {
                    ctx.fillStyle = 'rgba(0,0,0,0.6)';
                    ctx.fillRect(this.x, this.y - 8, this.width, 5);
                    ctx.fillStyle = '#22c55e';
                    ctx.fillRect(this.x, this.y - 8, this.width * (this.health / this.maxHealth), 5);
                }
            }
            update(dt) {
                this.pattern += dt * 2;
                if (this.type === 'fast') this.x += Math.sin(this.pattern * 2) * 3 * dt;
                if (this.type === 'zigzag') this.x += Math.sin(this.pattern * 4) * 5 * dt;
                if (this.type === 'boss') {
                    this.x += Math.sin(Date.now() / 600) * 0.8;
                    if (this.y < 80) this.y += 0.5;
                } else {
                    this.y += this.speed * dt;
                }
                if (this.type === 'tank' || this.type === 'boss') {
                    this.cooldown -= dt * 16.6;
                    if (this.cooldown <= 0) {
                        this.cooldown = this.type === 'boss' ? 600 : 900;
                        if (this.type === 'boss') {
                            for (let i = -2; i <= 2; i++) {
                                bullets.push(new Bullet(this.x + this.width / 2, this.y + this.height, i * 0.2, 7, 18, true));
                            }
                        } else {
                            bullets.push(new Bullet(this.x + this.width / 2, this.y + this.height, 0, 6, 15, true));
                        }
                    }
                }
                this.x = Math.max(5, Math.min(canvas.width - this.width - 5, this.x));
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.life = 1;
                this.decay = 0.02 + Math.random() * 0.02;
                this.color = color;
            }
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2 + Math.random() * 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= this.decay * dt;
            }
        }

        class Powerup {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 28;
                this.height = 28;
                this.type = ['health', 'shield', 'triple', 'rapid'][Math.floor(Math.random() * 4)];
                this.speed = 1.5;
                this.angle = 0;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                this.angle += 0.05;
                ctx.rotate(this.angle);
                ctx.font = '20px Segoe UI';
                const map = { health: '‚ù§Ô∏è', shield: 'üõ°Ô∏è', triple: 'üî±', rapid: '‚ö°' };
                ctx.fillText(map[this.type], 0, 6);
                ctx.restore();
                ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, 18, 0, Math.PI * 2);
                ctx.stroke();
            }
            update(dt) {
                this.y += this.speed * dt;
            }
        }

        class Meteor {
            constructor() {
                const side = Math.random() < 0.5;
                this.x = side ? -60 : canvas.width + 60;
                this.y = Math.random() * canvas.height * 0.6;
                const targetX = canvas.width / 2 + (Math.random() - 0.5) * canvas.width;
                const targetY = canvas.height + 100;
                const angle = Math.atan2(targetY - this.y, targetX - this.x);
                this.vx = Math.cos(angle) * (3 + Math.random() * 2);
                this.vy = Math.sin(angle) * (3 + Math.random() * 2);
                this.size = 30 + Math.random() * 20;
            }
            draw() {
                ctx.fillStyle = '#f97316';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 0.4, 0, Math.PI * 2);
                ctx.fill();
            }
            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
            }
        }

        function createStars() {
            const count = Math.min(150, Math.floor(canvas.width * canvas.height / 9000));
            stars = new Array(count).fill(0).map(() => ({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                speed: 0.3 + Math.random() * 1.2,
                size: Math.random() * 2 + 0.5,
                alpha: 0.2 + Math.random() * 0.8
            }));
        }

        function drawStars(dt) {
            stars.forEach(star => {
                ctx.fillStyle = `rgba(255,255,255,${star.alpha})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
                star.y += star.speed * dt;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });
        }

        function spawnEnemies(dt) {
            spawnTimer += dt * 16.6;
            const interval = Math.max(500, 1300 - wave * 50);
            if (spawnTimer >= interval) {
                spawnTimer = 0;
                const roll = Math.random();
                if (roll < 0.4) enemies.push(new Enemy('basic'));
                else if (roll < 0.65) enemies.push(new Enemy('fast'));
                else if (roll < 0.82) enemies.push(new Enemy('zigzag'));
                else enemies.push(new Enemy('tank'));
            }
            if (killsThisWave >= enemyGoal) {
                killsThisWave = 0;
                wave++;
                waveDisplay.textContent = wave;
                enemyGoal = 8 + wave * 3;
                if (wave % 4 === 0) enemies.push(new Enemy('boss'));
                if (wave % 3 === 0) triggerMeteorEvent();
            }
        }

        function triggerMeteorEvent() {
            meteorActive = true;
            meteorEventTimer = 5000;
            showEvent('–ú–µ—Ç–µ–æ—Ä–Ω—ã–π –¥–æ–∂–¥—å! –£–∫–ª–æ–Ω—è–π—Å—è!');
        }

        function showEvent(text) {
            eventText.textContent = text;
            eventBanner.classList.remove('hidden');
            setTimeout(() => eventBanner.classList.add('hidden'), 2200);
        }

        function updateHealth() {
            healthFill.style.width = `${Math.max(0, player.health)}%`;
        }

        function updatePowerDisplay() {
            const map = { shield: 'üõ°Ô∏è', triple: 'üî±', rapid: '‚ö°' };
            powerDisplay.textContent = map[currentPower] || '-';
        }

        function resetCombo() {
            combo = 1;
            comboDisplay.textContent = 'x1';
        }

        function addCombo() {
            combo = Math.min(combo + 1, 12);
            if (combo > maxCombo) maxCombo = combo;
            comboDisplay.textContent = `x${combo}`;
            comboTimer = 1800;
            if (combo >= 4) {
                comboPopup.textContent = `x${combo}!`;
                comboPopup.classList.remove('show');
                void comboPopup.offsetWidth;
                comboPopup.classList.add('show');
            }
            overdrive = Math.min(100, overdrive + 8);
            overdriveFill.style.width = `${overdrive}%`;
        }

        function applyPowerup(type) {
            if (type === 'health') {
                player.health = Math.min(player.maxHealth, player.health + 35);
                updateHealth();
            } else if (type === 'shield') {
                currentPower = 'shield';
                powerTimer = 6000;
                player.invulnerable = true;
                player.invulnerableTimer = 6000;
            } else if (type === 'triple') {
                currentPower = 'triple';
                powerTimer = 9000;
                player.tripleShot = true;
            } else if (type === 'rapid') {
                currentPower = 'rapid';
                powerTimer = 7000;
                player.fireRate = 70;
            }
            updatePowerDisplay();
        }

        function activateOverdrive() {
            if (overdrive < 100 || overdriveActive === true) return;
            overdriveActive = true;
            overdriveTimer = 5000;
            showEvent('OVERDRIVE!');
        }

        function handleCollisions() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                if (!bullet.enemy) {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        if (bullet.x > enemy.x && bullet.x < enemy.x + enemy.width && bullet.y > enemy.y && bullet.y < enemy.y + enemy.height) {
                            enemy.health -= bullet.damage;
                            particles.push(new Particle(bullet.x, bullet.y, enemy.color));
                            bullets.splice(i, 1);
                            if (enemy.health <= 0) {
                                createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, enemy.color, 18);
                                enemies.splice(j, 1);
                                killsThisWave++;
                                addCombo();
                                const gained = enemy.score * combo;
                                score += gained;
                                scoreDisplay.textContent = score;
                                if (Math.random() < 0.22) powerups.push(new Powerup(enemy.x, enemy.y));
                            }
                            break;
                        }
                    }
                } else {
                    if (bullet.x > player.x && bullet.x < player.x + player.width && bullet.y > player.y && bullet.y < player.y + player.height) {
                        player.damage(bullet.damage || 10);
                        particles.push(new Particle(bullet.x, bullet.y, '#f87171'));
                        bullets.splice(i, 1);
                    }
                }
            }
            enemies.forEach(enemy => {
                if (player.x < enemy.x + enemy.width && player.x + player.width > enemy.x && player.y < enemy.y + enemy.height && player.y + player.height > enemy.y) {
                    player.damage(enemy.type === 'boss' ? 40 : 20);
                    createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, enemy.color, 25);
                    enemies.splice(enemies.indexOf(enemy), 1);
                }
            });
            powerups.forEach((p, idx) => {
                if (player.x < p.x + p.width && player.x + player.width > p.x && player.y < p.y + p.height && player.y + player.height > p.y) {
                    applyPowerup(p.type);
                    createExplosion(p.x + p.width / 2, p.y + p.height / 2, '#fff', 10);
                    powerups.splice(idx, 1);
                }
            });
            meteors.forEach((m, idx) => {
                if (player.x < m.x + m.size && player.x + player.width > m.x - m.size && player.y < m.y + m.size && player.y + player.height > m.y - m.size) {
                    player.damage(35);
                    meteors.splice(idx, 1);
                    createExplosion(m.x, m.y, '#f97316', 40);
                }
            });
        }

        function createExplosion(x, y, color, count = 12) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        function cleanup(dt) {
            bullets = bullets.filter(b => b.y > -80 && b.y < canvas.height + 80);
            enemies = enemies.filter(e => e.y < canvas.height + 80);
            powerups = powerups.filter(p => p.y < canvas.height + 100);
            particles = particles.filter(p => p.life > 0);
            meteors = meteors.filter(m => m.y < canvas.height + 150);
            if (powerTimer > 0) {
                powerTimer -= dt * 16.6;
                if (powerTimer <= 0) {
                    currentPower = null;
                    player.fireRate = player.baseFireRate;
                    player.tripleShot = false;
                    player.invulnerable = false;
                    updatePowerDisplay();
                }
            }
            if (comboTimer > 0) {
                comboTimer -= dt * 16.6;
                if (comboTimer <= 0) resetCombo();
            }
            if (overdriveActive) {
                overdriveTimer -= dt * 16.6;
                overdriveFill.style.width = `${Math.max(0, (overdriveTimer / 5000) * 100)}%`;
                if (overdriveTimer <= 0) {
                    overdriveActive = false;
                    overdrive = 0;
                    overdriveFill.style.width = '0%';
                }
            }
            if (meteorActive) {
                meteorEventTimer -= dt * 16.6;
                if (meteorEventTimer <= 0) meteorActive = false;
                else if (Math.random() < 0.08) meteors.push(new Meteor());
            }
        }

        function gameLoop(time) {
            if (!gameRunning) return;
            if (!lastTime) lastTime = time;
            let delta = time - lastTime;
            lastTime = time;
            if (delta > 100) delta = 100;
            accumulator += delta;

            while (accumulator >= FIXED_DT) {
                const dt = FIXED_DT / 16.6;
                if (!paused) update(dt);
                accumulator -= FIXED_DT;
            }
            if (!paused) render(FIXED_DT / 16.6);
            requestAnimationFrame(gameLoop);
        }

        function update(dt) {
            player.update(dt);
            if (keys['Space'] || fireHeld) player.shoot();
            bullets.forEach(b => b.update(dt));
            enemies.forEach(e => e.update(dt));
            particles.forEach(p => p.update(dt));
            powerups.forEach(p => p.update(dt));
            meteors.forEach(m => m.update(dt));
            spawnEnemies(dt);
            if (meteorActive && Math.random() < 0.02) meteors.push(new Meteor());
            handleCollisions();
            cleanup(dt);
        }

        function render(dt) {
            ctx.fillStyle = '#03030b';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawStars(dt);
            meteors.forEach(m => m.draw());
            powerups.forEach(p => p.draw());
            bullets.forEach(b => b.draw());
            enemies.forEach(e => e.draw());
            particles.forEach(p => p.draw());
            player.draw();
            if (paused) {
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 42px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText('–ü–∞—É–∑–∞', canvas.width / 2, canvas.height / 2);
            }
        }

        function startGame() {
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            hud.classList.remove('hidden');
            pauseButton.classList.remove('hidden');
            if (isMobile) document.getElementById('mobileControls').classList.remove('hidden');
            player = new Player();
            bullets = [];
            enemies = [];
            particles = [];
            powerups = [];
            meteors = [];
            stars = [];
            score = 0;
            wave = 1;
            spawnTimer = 0;
            enemyGoal = 10;
            killsThisWave = 0;
            combo = 1;
            comboTimer = 0;
            maxCombo = 1;
            currentPower = null;
            powerTimer = 0;
            overdrive = 0;
            overdriveActive = false;
            meteorActive = false;
            updateHealth();
            updatePowerDisplay();
            scoreDisplay.textContent = '0';
            waveDisplay.textContent = '1';
            comboDisplay.textContent = 'x1';
            overdriveFill.style.width = '0%';
            lastTime = 0;
            accumulator = 0;
            gameRunning = true;
            paused = false;
            pauseButton.textContent = '‚è∏Ô∏è';
            createStars();
            requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            if (!gameRunning) return;
            gameRunning = false;
            hud.classList.add('hidden');
            pauseButton.classList.add('hidden');
            document.getElementById('mobileControls').classList.add('hidden');
            gameOverScreen.classList.remove('hidden');
            finalScore.textContent = score;
            finalWave.textContent = wave;
            finalCombo.textContent = `x${maxCombo}`;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('sd40-highscore', highScore);
            }
            highScoreEl.textContent = highScore;
        }

        function togglePause() {
            if (!gameRunning) return;
            paused = !paused;
            pauseButton.textContent = paused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
        }

        document.addEventListener('keydown', e => {
            keys[e.code] = true;
            if ((e.code === 'KeyP' || e.code === 'Escape') && gameRunning) togglePause();
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') activateOverdrive();
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
        });
        document.addEventListener('keyup', e => { keys[e.code] = false; });
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && gameRunning && !paused) togglePause();
        });

        // Mobile controls setup
        const joystickArea = document.getElementById('joystickArea');
        const joystickThumb = document.getElementById('joystickThumb');
        const fireButton = document.getElementById('fireButton');
        const overdriveButton = document.getElementById('overdriveButton');

        function moveJoystick(x, y) {
            const rect = joystickArea.getBoundingClientRect();
            const cx = rect.left + rect.width / 2;
            const cy = rect.top + rect.height / 2;
            let dx = x - cx;
            let dy = y - cy;
            const max = 55;
            const dist = Math.hypot(dx, dy);
            if (dist > max) {
                dx = (dx / dist) * max;
                dy = (dy / dist) * max;
            }
            joystickThumb.style.left = `calc(50% + ${dx}px)`;
            joystickThumb.style.top = `calc(50% + ${dy}px)`;
            joystickVector.x = dx / max;
            joystickVector.y = dy / max;
        }
        function resetJoystick() {
            joystickThumb.style.left = '50%';
            joystickThumb.style.top = '50%';
            joystickVector.x = 0;
            joystickVector.y = 0;
            joystickActive = false;
        }
        if (joystickArea) {
            ['touchstart', 'touchmove'].forEach(evt => {
                joystickArea.addEventListener(evt, e => {
                    e.preventDefault();
                    joystickActive = true;
                    moveJoystick(e.touches[0].clientX, e.touches[0].clientY);
                }, { passive: false });
            });
            ['touchend', 'touchcancel'].forEach(evt => {
                joystickArea.addEventListener(evt, e => {
                    e.preventDefault();
                    resetJoystick();
                }, { passive: false });
            });
        }
        fireButton?.addEventListener('touchstart', e => { e.preventDefault(); fireHeld = true; }, { passive: false });
        fireButton?.addEventListener('touchend', e => { e.preventDefault(); fireHeld = false; }, { passive: false });
        fireButton?.addEventListener('touchcancel', () => { fireHeld = false; });
        overdriveButton?.addEventListener('touchstart', e => { e.preventDefault(); activateOverdrive(); }, { passive: false });

        document.addEventListener('touchmove', e => {
            if (e.touches.length > 1) e.preventDefault();
        }, { passive: false });

        // Animated idle background
        createStars();
        let idleLast = 0;
        function idleLoop(time) {
            if (gameRunning) return;
            if (!idleLast) idleLast = time;
            const dt = Math.min(32, time - idleLast);
            idleLast = time;
            ctx.fillStyle = '#03030b';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawStars(dt / 10);
            requestAnimationFrame(idleLoop);
        }
        requestAnimationFrame(idleLoop);
        highScoreEl.textContent = highScore;
    </script>
</body>
</html>
